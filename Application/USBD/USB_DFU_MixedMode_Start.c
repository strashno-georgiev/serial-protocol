/*********************************************************************
*                     SEGGER Microcontroller GmbH                    *
*                        The Embedded Experts                        *
**********************************************************************
*                                                                    *
*       (c) 2003 - 2022  SEGGER Microcontroller GmbH                 *
*                                                                    *
*       www.segger.com     Support: support@segger.com               *
*                                                                    *
**********************************************************************
-------------------------- END-OF-HEADER -----------------------------

Purpose : This sample demonstrates a CDC or HID echo server (see MAIN_INTERFACE define)
          that has an additional DFU interface. The device runs in a single configuration,
          there is no need to switch between runtime mode and DFU mode since the device
          is able to accept DFU download at runtime.

Additional information:
  Preparations:
    Test can be done using the dfu-util tool.
    Take an arbitrary file and add a dfu-suffix:
      dfu-suffix -v 8765 -d 1010 -a <file>
    Start and connect device. Then download the file:
      dfu-util -d 8765:1010 -D <file>
    On Linux it may be necessary to execute this command with root rights.
    ATTENTION: if using the CDC interface, replace 1010 by 1020.

  Expected behavior:
    The device accepts the downloaded file an display it in the terminal window.

  Sample output (PC):
    dfu-util 0.9
    Copyright 2005-2009 Weston Schmidt, Harald Welte and OpenMoko Inc.
    Copyright 2010-2016 Tormod Volden and Stefan Schmidt
    This program is Free Software and has ABSOLUTELY NO WARRANTY
    Please report bugs to http://sourceforge.net/p/dfu-util/tickets/
    Opening DFU capable USB device...
    ID 8765:1020
    Run-time device DFU version 0110
    Claiming USB DFU Runtime Interface...
    Determining device status: state = dfuIDLE, status = 0
    dfu-util: WARNING: Runtime device already in DFU state ?!?
    Claiming USB DFU Interface...
    Setting Alternate Setting #0 ...
    Determining device status: state = dfuIDLE, status = 0
    dfuIDLE, continuing
    DFU mode device DFU version 0110
    Device returned transfer size 256
    Copying data from PC to DFU device
    Download    [=========================] 100%         3042 bytes
    Download done.
    state(6) = dfuMANIFEST-SYNC, status(0) = No error condition is present
    state(6) = dfuMANIFEST-SYNC, status(0) = No error condition is present
    state(2) = dfuIDLE, status(0) = No error condition is present
    Done!

  Sample output (Target):
    16:022 MainTask - Download received, block #0:
    16:022 MainTask - 0000  2F 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A
    16:022 MainTask - 0010  2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A
    16:022 MainTask - 0020  2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A
    16:022 MainTask - 0030  2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A
    16:022 MainTask - 0040  2A 2A 2A 2A 2A 2A 0D 0A 2A 20 20 20 20 20 20 20
    16:022 MainTask - 0050  20 20 20 20 20 20 20 20 20 20 20 20 28 63 29 20
    16:022 MainTask - 0060  53 45 47 47 45 52 20 4D 69 63 72 6F 63 6F 6E 74
    16:022 MainTask - 0070  72 6F 6C 6C 65 72 20 47 6D 62 48 20 20 20 20 20
    16:022 MainTask - 0080  20 20 20 20 20 20 20 20 20 20 20 20 20 2A 0D 0A
    16:022 MainTask - 0090  2A 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20
    16:022 MainTask - 00A0  20 20 20 20 20 20 20 20 20 54 68 65 20 45 6D 62
    16:023 MainTask - 00B0  65 64 64 65 64 20 45 78 70 65 72 74 73 20 20 20
    16:023 MainTask - 00C0  20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20
    16:023 MainTask - 00D0  20 20 20 20 20 2A 0D 0A 2A 2A 2A 2A 2A 2A 2A 2A
    16:023 MainTask - 00E0  2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A
    16:025 MainTask - 00F0  2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A
    16:375 MainTask - Download received, block #1:
    16:375 MainTask - 0000  2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A
    16:375 MainTask - 0010  2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 0D 0A
    16:375 MainTask - 0020  2A 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20
    16:375 MainTask - 0030  20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20
    ......
    20:348 MainTask - 00A0  2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A
    20:349 MainTask - 00B0  2A 2A 2A 2A 2A 2A 20 45 6E 64 20 6F 66 20 66 69
    20:349 MainTask - 00C0  6C 65 20 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A
    20:349 MainTask - 00D0  2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2F
    20:350 MainTask - 00E0  0D 0A
    20:750 MainTask - Download finished, now manifestation
    22:750 MainTask - Done.
*/

/*********************************************************************
*
*       #include section
*
**********************************************************************
*/
#ifndef USBD_SAMPLE_NO_MAINTASK
  #define MAIN_INTERFACE           0       // Select: 0 = HID, 1 = CDC
  #define USBD_SAMPLE_NO_MAINTASK  0
#else
  #define MAIN_INTERFACE          -1       // No main interface defined in this C file
#endif

#include <string.h>
#include "USB.h"
#if MAIN_INTERFACE == 0
#include "USB_HID.h"
#endif
#if MAIN_INTERFACE == 1
#include "USB_CDC.h"
#endif
#include "USB_DFU.h"
#include "BSP.h"

/*********************************************************************
*
*       Defines configurable
*
**********************************************************************
*/
//
// Definitions for the HID interface
//
#define INPUT_REPORT_SIZE   64    // Defines the input (device -> host) report size
#define OUTPUT_REPORT_SIZE  64    // Defines the output (Host -> device) report size
#define VENDOR_PAGE_ID      0x12  // Defines the vendor specific page that
                                  // shall be used, allowed values 0x00 - 0xff
                                  // This value must be identical to HOST application

/*********************************************************************
*
*       Forward declarations
*
**********************************************************************
*/
#ifdef __cplusplus
extern "C" {     /* Make sure we have C-declarations in C++ programs */
#endif
void MainTask(void);
void USBD_DFU_MixedMode_Init(void);
void USBD_DFU_MixedMode_RunTask(void *);
#ifdef __cplusplus
}
#endif

/*********************************************************************
*
*       Static const data
*
**********************************************************************
*/
//
//  Information that is used during enumeration.
//
#if USBD_SAMPLE_NO_MAINTASK == 0
static const USB_DEVICE_INFO _DeviceInfo = {
  0x8765,                           // VendorId
  0x1010 + 0x10 * MAIN_INTERFACE,   // ProductId. Should be unique for this sample
  "Vendor",                         // VendorName
  "DFU sample",                     // ProductName
  "12345678"                        // SerialNumber
};
#endif

static U8                _Buff[256];
static USBD_DFU_DOWNLOAD _Download;
static USBD_DFU_UPLOAD   _Upload;

static const USB_DFU_INIT_DATA _DFUInfo = {
  USB_DFU_MODE_MIXED,                                       // Mode
  USB_DFU_ATTR_DOWNLOAD | USB_DFU_ATTR_UPLOAD |
                          USB_DFU_ATTR_MANIFEST_TOLERANT,   // Attributes
  0,                                                        // Detach timeout
  sizeof(_Buff),                                            // Transfer size
  0,                                                        // Flags
  "DFU interface",                                          // Interface name
  NULL,                                                     // Callback for detach request
  _Download,                                                // Callback for download data
  _Buff,                                                    // Download buffer
  _Upload                                                   // Callback for upload data
};


#if MAIN_INTERFACE == 0
static const U8 _aHIDReport[] = {
    0x06, VENDOR_PAGE_ID, 0xFF,    // USAGE_PAGE (Vendor Defined Page 1)
    0x09, 0x01,                    // USAGE (Vendor Usage 1)
    0xa1, 0x01,                    // COLLECTION (Application)
    0x05, 0x06,                    //   USAGE_PAGE (Generic Device)
    0x09, 0x00,                    //   USAGE (Undefined)
    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
    0x26, 0xFF, 0x00,              //   LOGICAL_MAXIMUM (255)
    0x95, INPUT_REPORT_SIZE,       //   REPORT_COUNT (64)
    0x75, 0x08,                    //   REPORT_SIZE (8)
    0x81, 0x02,                    //   INPUT (Data,Var,Abs)
    0x05, 0x06,                    //   USAGE_PAGE (Generic Device)
    0x09, 0x00,                    //   USAGE (Undefined)
    0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
    0x26, 0xFF, 0x00,              //   LOGICAL_MAXIMUM (255)
    0x95, OUTPUT_REPORT_SIZE,      //   REPORT_COUNT (64)
    0x75, 0x08,                    //   REPORT_SIZE (8)
    0x91, 0x02,                    //   OUTPUT (Data,Var,Abs)
    0xc0                           // END_COLLECTION
};
#endif

static const U8 _FirmwareForUpload[] = {
  0x2a, 0x2a, 0x2a, 0x20, 0x46, 0x69, 0x72, 0x6d, 0x77, 0x61, 0x72, 0x65, 0x20, 0x2a, 0x2a, 0x2a, 0x0a, 0x20, 0x20, 0x2a, 0x2a, 0x2a, 0x20, 0x46, 0x69, 0x72, 0x6d, 0x77, 0x61, 0x72, 0x65, 0x20,
  0x2a, 0x2a, 0x2a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x2a, 0x2a, 0x2a, 0x20, 0x46, 0x69, 0x72, 0x6d, 0x77, 0x61, 0x72, 0x65, 0x20, 0x2a, 0x2a, 0x2a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2a,
  0x2a, 0x2a, 0x20, 0x46, 0x69, 0x72, 0x6d, 0x77, 0x61, 0x72, 0x65, 0x20, 0x2a, 0x2a, 0x2a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2a, 0x2a, 0x2a, 0x20, 0x46, 0x69, 0x72, 0x6d,
  0x77, 0x61, 0x72, 0x65, 0x20, 0x2a, 0x2a, 0x2a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2a, 0x2a, 0x2a, 0x20, 0x46, 0x69, 0x72, 0x6d, 0x77, 0x61, 0x72, 0x65, 0x20,
  0x2a, 0x2a, 0x2a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2a, 0x2a, 0x2a, 0x20, 0x46, 0x69, 0x72, 0x6d, 0x77, 0x61, 0x72, 0x65, 0x20, 0x2a, 0x2a, 0x2a,
  0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2a, 0x2a, 0x2a, 0x20, 0x46, 0x69, 0x72, 0x6d, 0x77, 0x61, 0x72, 0x65, 0x20, 0x2a, 0x2a, 0x2a, 0x0a,
  0x65, 0x62, 0x35, 0x38, 0x20, 0x63, 0x65, 0x39, 0x62, 0x20, 0x30, 0x39, 0x38, 0x32, 0x20, 0x63, 0x64, 0x31, 0x32, 0x20, 0x61, 0x34, 0x63, 0x39, 0x20, 0x36, 0x61, 0x37, 0x65, 0x20, 0x37, 0x64,
  0x37, 0x66, 0x20, 0x38, 0x35, 0x62, 0x62, 0x20, 0x63, 0x34, 0x36, 0x32, 0x20, 0x63, 0x34, 0x64, 0x34, 0x20, 0x31, 0x63, 0x32, 0x65, 0x20, 0x62, 0x65, 0x39, 0x61, 0x20, 0x35, 0x64, 0x39, 0x65,
  0x20, 0x62, 0x64, 0x66, 0x35, 0x20, 0x39, 0x39, 0x34, 0x62, 0x20, 0x66, 0x62, 0x61, 0x37, 0x0a, 0x64, 0x61, 0x35, 0x33, 0x20, 0x34, 0x32, 0x61, 0x36, 0x20, 0x64, 0x34, 0x31, 0x31, 0x20, 0x32,
  0x39, 0x64, 0x33, 0x20, 0x65, 0x36, 0x30, 0x39, 0x20, 0x32, 0x61, 0x39, 0x39, 0x20, 0x33, 0x32, 0x63, 0x63, 0x20, 0x31, 0x36, 0x66, 0x31, 0x20, 0x33, 0x34, 0x37, 0x34, 0x20, 0x61, 0x36, 0x35,
  0x64, 0x20, 0x61, 0x61, 0x31, 0x34, 0x20, 0x33, 0x39, 0x61, 0x32, 0x20, 0x64, 0x35, 0x33, 0x62, 0x20, 0x62, 0x66, 0x63, 0x38, 0x20, 0x61, 0x65, 0x62, 0x61, 0x20, 0x31, 0x63, 0x36, 0x61, 0x0a,
  0x34, 0x30, 0x31, 0x64, 0x20, 0x38, 0x65, 0x66, 0x37, 0x20, 0x63, 0x33, 0x38, 0x61, 0x20, 0x62, 0x30, 0x37, 0x65, 0x20, 0x37, 0x33, 0x66, 0x35, 0x20, 0x39, 0x37, 0x36, 0x65, 0x20, 0x36, 0x66,
  0x33, 0x34, 0x20, 0x33, 0x64, 0x37, 0x37, 0x20, 0x36, 0x64, 0x38, 0x35, 0x20, 0x64, 0x62, 0x63, 0x34, 0x20, 0x37, 0x65, 0x66, 0x63, 0x20, 0x62, 0x36, 0x36, 0x61, 0x20, 0x33, 0x37, 0x30, 0x30,
  0x20, 0x36, 0x35, 0x37, 0x62, 0x20, 0x37, 0x37, 0x36, 0x33, 0x20, 0x30, 0x39, 0x66, 0x62, 0x0a, 0x32, 0x63, 0x64, 0x35, 0x20, 0x30, 0x65, 0x36, 0x33, 0x20, 0x34, 0x66, 0x32, 0x33, 0x20, 0x32,
  0x32, 0x32, 0x64, 0x20, 0x31, 0x64, 0x61, 0x62, 0x20, 0x66, 0x65, 0x33, 0x38, 0x20, 0x64, 0x64, 0x66, 0x33, 0x20, 0x33, 0x36, 0x35, 0x32, 0x20, 0x30, 0x31, 0x63, 0x38, 0x20, 0x34, 0x38, 0x37,
  0x34, 0x20, 0x36, 0x30, 0x64, 0x36, 0x20, 0x62, 0x32, 0x31, 0x63, 0x20, 0x32, 0x30, 0x35, 0x30, 0x20, 0x39, 0x34, 0x36, 0x38, 0x20, 0x35, 0x61, 0x64, 0x31, 0x20, 0x63, 0x32, 0x61, 0x32, 0x0a,
  0x32, 0x34, 0x62, 0x64, 0x20, 0x38, 0x37, 0x33, 0x39, 0x20, 0x61, 0x61, 0x61, 0x62, 0x20, 0x61, 0x61, 0x36, 0x32, 0x20, 0x32, 0x32, 0x66, 0x38, 0x20, 0x62, 0x31, 0x33, 0x34, 0x20, 0x63, 0x36,
  0x37, 0x66, 0x20, 0x37, 0x34, 0x61, 0x34, 0x20, 0x31, 0x37, 0x39, 0x32, 0x20, 0x30, 0x36, 0x64, 0x65, 0x20, 0x62, 0x30, 0x63, 0x61, 0x20, 0x61, 0x62, 0x38, 0x30, 0x20, 0x66, 0x32, 0x63, 0x36,
  0x20, 0x66, 0x65, 0x63, 0x66, 0x20, 0x34, 0x30, 0x30, 0x64, 0x20, 0x34, 0x38, 0x37, 0x31, 0x0a, 0x65, 0x37, 0x63, 0x36, 0x20, 0x62, 0x39, 0x64, 0x66, 0x20, 0x36, 0x63, 0x33, 0x31, 0x20, 0x33,
  0x36, 0x32, 0x38, 0x20, 0x64, 0x61, 0x30, 0x33, 0x20, 0x34, 0x63, 0x32, 0x30, 0x20, 0x33, 0x35, 0x39, 0x33, 0x20, 0x33, 0x32, 0x63, 0x31, 0x20, 0x63, 0x38, 0x36, 0x66, 0x20, 0x38, 0x39, 0x62,
  0x33, 0x20, 0x39, 0x39, 0x30, 0x32, 0x20, 0x64, 0x66, 0x35, 0x61, 0x20, 0x32, 0x63, 0x66, 0x33, 0x20, 0x61, 0x37, 0x37, 0x66, 0x20, 0x38, 0x64, 0x38, 0x64, 0x20, 0x36, 0x31, 0x66, 0x37, 0x0a,
  0x38, 0x63, 0x38, 0x38, 0x20, 0x36, 0x64, 0x64, 0x35, 0x20, 0x36, 0x37, 0x63, 0x65, 0x20, 0x34, 0x66, 0x39, 0x32, 0x20, 0x65, 0x64, 0x62, 0x36, 0x20, 0x65, 0x66, 0x38, 0x33, 0x20, 0x39, 0x65,
  0x39, 0x36, 0x20, 0x35, 0x65, 0x32, 0x31, 0x20, 0x64, 0x66, 0x33, 0x39, 0x20, 0x36, 0x66, 0x30, 0x32, 0x20, 0x63, 0x39, 0x31, 0x35, 0x20, 0x39, 0x66, 0x31, 0x35, 0x20, 0x63, 0x37, 0x31, 0x33,
  0x20, 0x65, 0x66, 0x39, 0x63, 0x20, 0x34, 0x64, 0x66, 0x37, 0x20, 0x39, 0x37, 0x30, 0x35, 0x0a, 0x66, 0x37, 0x35, 0x66, 0x20, 0x65, 0x31, 0x37, 0x33, 0x20, 0x61, 0x39, 0x33, 0x30, 0x20, 0x39,
  0x63, 0x34, 0x65, 0x20, 0x64, 0x65, 0x63, 0x63, 0x20, 0x32, 0x65, 0x31, 0x33, 0x20, 0x34, 0x38, 0x66, 0x30, 0x20, 0x61, 0x63, 0x31, 0x64, 0x20, 0x38, 0x32, 0x36, 0x62, 0x20, 0x35, 0x34, 0x63,
  0x34, 0x20, 0x38, 0x34, 0x35, 0x33, 0x20, 0x33, 0x31, 0x64, 0x65, 0x20, 0x35, 0x37, 0x65, 0x66, 0x20, 0x37, 0x30, 0x63, 0x34, 0x20, 0x38, 0x35, 0x63, 0x62, 0x20, 0x31, 0x37, 0x35, 0x65, 0x0a,
  0x66, 0x62, 0x34, 0x35, 0x20, 0x61, 0x37, 0x65, 0x31, 0x20, 0x66, 0x32, 0x34, 0x31, 0x20, 0x36, 0x34, 0x65, 0x35, 0x20, 0x36, 0x66, 0x35, 0x34, 0x20, 0x33, 0x66, 0x61, 0x63, 0x20, 0x32, 0x34,
  0x31, 0x38, 0x20, 0x33, 0x64, 0x39, 0x62, 0x20, 0x64, 0x66, 0x62, 0x38, 0x20, 0x31, 0x33, 0x31, 0x65, 0x20, 0x61, 0x66, 0x61, 0x63, 0x20, 0x65, 0x32, 0x32, 0x33, 0x20, 0x38, 0x35, 0x64, 0x35,
  0x20, 0x64, 0x31, 0x38, 0x30, 0x20, 0x61, 0x66, 0x64, 0x37, 0x20, 0x38, 0x33, 0x30, 0x66, 0x0a, 0x35, 0x63, 0x33, 0x32, 0x20, 0x64, 0x34, 0x65, 0x31, 0x20, 0x62, 0x34, 0x33, 0x39, 0x20, 0x61,
  0x34, 0x33, 0x66, 0x20, 0x62, 0x33, 0x65, 0x30, 0x20, 0x63, 0x31, 0x66, 0x37, 0x20, 0x39, 0x35, 0x35, 0x66, 0x20, 0x31, 0x35, 0x36, 0x37, 0x20, 0x36, 0x64, 0x37, 0x61, 0x20, 0x36, 0x39, 0x32,
  0x38, 0x20, 0x63, 0x62, 0x32, 0x35, 0x20, 0x34, 0x62, 0x31, 0x33, 0x20, 0x65, 0x63, 0x64, 0x64, 0x20, 0x63, 0x37, 0x30, 0x61, 0x20, 0x62, 0x36, 0x33, 0x32, 0x20, 0x37, 0x62, 0x38, 0x33, 0x0a,
  0x31, 0x33, 0x66, 0x34, 0x20, 0x65, 0x37, 0x34, 0x31, 0x20, 0x64, 0x34, 0x64, 0x38, 0x20, 0x65, 0x38, 0x33, 0x34, 0x20, 0x36, 0x33, 0x66, 0x66, 0x20, 0x66, 0x31, 0x35, 0x63, 0x20, 0x38, 0x34,
  0x37, 0x30, 0x20, 0x61, 0x33, 0x35, 0x33, 0x20, 0x30, 0x35, 0x36, 0x65, 0x20, 0x65, 0x38, 0x39, 0x39, 0x20, 0x36, 0x35, 0x39, 0x32, 0x20, 0x34, 0x37, 0x34, 0x65, 0x20, 0x34, 0x38, 0x36, 0x31,
  0x20, 0x64, 0x64, 0x38, 0x64, 0x20, 0x63, 0x65, 0x66, 0x38, 0x20, 0x36, 0x61, 0x36, 0x34, 0x0a, 0x63, 0x38, 0x37, 0x32, 0x20, 0x36, 0x33, 0x64, 0x62, 0x20, 0x33, 0x63, 0x39, 0x65, 0x20, 0x65,
  0x63, 0x33, 0x30, 0x20, 0x33, 0x39, 0x36, 0x31, 0x20, 0x30, 0x62, 0x65, 0x36, 0x20, 0x64, 0x62, 0x35, 0x65, 0x20, 0x37, 0x66, 0x32, 0x38, 0x20, 0x33, 0x66, 0x31, 0x35, 0x20, 0x36, 0x35, 0x62,
  0x34, 0x20, 0x65, 0x36, 0x34, 0x30, 0x20, 0x37, 0x65, 0x30, 0x37, 0x20, 0x36, 0x36, 0x32, 0x36, 0x20, 0x65, 0x61, 0x39, 0x35, 0x20, 0x63, 0x37, 0x31, 0x30, 0x20, 0x64, 0x35, 0x37, 0x31, 0x0a,
  0x65, 0x30, 0x63, 0x31, 0x20, 0x35, 0x33, 0x33, 0x63, 0x20, 0x64, 0x65, 0x38, 0x66, 0x20, 0x35, 0x34, 0x34, 0x63, 0x20, 0x61, 0x63, 0x64, 0x34, 0x20, 0x37, 0x34, 0x39, 0x33, 0x20, 0x32, 0x62,
  0x63, 0x32, 0x20, 0x35, 0x38, 0x32, 0x33, 0x20, 0x62, 0x35, 0x37, 0x34, 0x20, 0x33, 0x36, 0x35, 0x36, 0x20, 0x32, 0x65, 0x32, 0x32, 0x20, 0x36, 0x31, 0x61, 0x66, 0x20, 0x34, 0x30, 0x39, 0x30,
  0x20, 0x36, 0x32, 0x65, 0x62, 0x20, 0x36, 0x38, 0x62, 0x61, 0x20, 0x35, 0x36, 0x37, 0x61, 0x0a, 0x61, 0x61, 0x32, 0x36, 0x20, 0x36, 0x64, 0x62, 0x39, 0x20, 0x65, 0x31, 0x62, 0x62, 0x20, 0x30,
  0x64, 0x66, 0x34, 0x20, 0x64, 0x63, 0x64, 0x36, 0x20, 0x35, 0x33, 0x64, 0x32, 0x20, 0x36, 0x63, 0x31, 0x36, 0x20, 0x63, 0x33, 0x39, 0x65, 0x20, 0x34, 0x62, 0x39, 0x39, 0x20, 0x65, 0x39, 0x61,
  0x38, 0x20, 0x33, 0x31, 0x30, 0x33, 0x20, 0x63, 0x61, 0x31, 0x37, 0x20, 0x30, 0x30, 0x38, 0x34, 0x20, 0x32, 0x32, 0x62, 0x63, 0x20, 0x34, 0x61, 0x31, 0x65, 0x20, 0x65, 0x34, 0x65, 0x36, 0x0a,
  0x39, 0x63, 0x63, 0x62, 0x20, 0x33, 0x65, 0x34, 0x64, 0x20, 0x34, 0x30, 0x33, 0x39, 0x20, 0x39, 0x36, 0x66, 0x61, 0x20, 0x39, 0x38, 0x62, 0x35, 0x20, 0x33, 0x36, 0x62, 0x37, 0x20, 0x32, 0x65,
  0x62, 0x39, 0x20, 0x37, 0x66, 0x31, 0x64, 0x20, 0x65, 0x35, 0x35, 0x66, 0x20, 0x33, 0x62, 0x33, 0x38, 0x20, 0x30, 0x36, 0x30, 0x32, 0x20, 0x38, 0x64, 0x61, 0x64, 0x20, 0x35, 0x33, 0x35, 0x36,
  0x20, 0x38, 0x34, 0x30, 0x39, 0x20, 0x32, 0x62, 0x37, 0x61, 0x20, 0x61, 0x37, 0x35, 0x62, 0x0a, 0x65, 0x37, 0x62, 0x61, 0x20, 0x33, 0x36, 0x65, 0x37, 0x20, 0x61, 0x38, 0x64, 0x35, 0x20, 0x35,
  0x62, 0x35, 0x65, 0x20, 0x36, 0x35, 0x64, 0x32, 0x20, 0x34, 0x63, 0x39, 0x64, 0x20, 0x39, 0x33, 0x63, 0x37, 0x20, 0x35, 0x30, 0x30, 0x31, 0x20, 0x37, 0x31, 0x64, 0x66, 0x20, 0x33, 0x39, 0x37,
  0x34, 0x20, 0x61, 0x31, 0x34, 0x62, 0x20, 0x62, 0x65, 0x62, 0x33, 0x20, 0x31, 0x63, 0x34, 0x34, 0x20, 0x35, 0x39, 0x66, 0x32, 0x20, 0x35, 0x64, 0x30, 0x62, 0x20, 0x64, 0x38, 0x63, 0x35, 0x0a,
  0x66, 0x36, 0x62, 0x62, 0x20, 0x31, 0x64, 0x37, 0x30, 0x20, 0x62, 0x32, 0x61, 0x64, 0x20, 0x65, 0x31, 0x36, 0x64, 0x20, 0x35, 0x31, 0x66, 0x34, 0x20, 0x32, 0x62, 0x65, 0x66, 0x20, 0x66, 0x65,
  0x65, 0x30, 0x20, 0x61, 0x32, 0x34, 0x39, 0x20, 0x34, 0x38, 0x61, 0x31, 0x20, 0x65, 0x61, 0x62, 0x33, 0x20, 0x35, 0x62, 0x30, 0x61, 0x20, 0x35, 0x30, 0x64, 0x37, 0x20, 0x64, 0x35, 0x62, 0x66,
  0x20, 0x64, 0x61, 0x35, 0x39, 0x20, 0x64, 0x31, 0x31, 0x66, 0x20, 0x64, 0x61, 0x37, 0x64, 0x0a, 0x66, 0x33, 0x30, 0x36, 0x20, 0x61, 0x61, 0x63, 0x63, 0x20, 0x36, 0x62, 0x64, 0x38, 0x20, 0x36,
  0x31, 0x63, 0x33, 0x20, 0x30, 0x63, 0x63, 0x36, 0x20, 0x34, 0x34, 0x63, 0x63, 0x20, 0x62, 0x30, 0x64, 0x33, 0x20, 0x38, 0x64, 0x61, 0x34, 0x20, 0x66, 0x32, 0x66, 0x33, 0x20, 0x61, 0x36, 0x64,
  0x33, 0x20, 0x62, 0x62, 0x36, 0x38, 0x20, 0x32, 0x62, 0x39, 0x35, 0x20, 0x63, 0x35, 0x39, 0x64, 0x20, 0x33, 0x33, 0x35, 0x39, 0x20, 0x61, 0x66, 0x62, 0x39, 0x20, 0x65, 0x36, 0x34, 0x34, 0x0a,
  0x34, 0x66, 0x37, 0x36, 0x20, 0x61, 0x63, 0x63, 0x63, 0x20, 0x33, 0x66, 0x31, 0x62, 0x20, 0x64, 0x62, 0x61, 0x61, 0x20, 0x61, 0x63, 0x62, 0x33, 0x20, 0x36, 0x63, 0x62, 0x32, 0x20, 0x63, 0x37,
  0x35, 0x37, 0x20, 0x61, 0x35, 0x64, 0x31, 0x20, 0x30, 0x33, 0x65, 0x61, 0x20, 0x36, 0x66, 0x34, 0x36, 0x20, 0x65, 0x33, 0x30, 0x61, 0x20, 0x33, 0x31, 0x38, 0x38, 0x20, 0x66, 0x64, 0x33, 0x39,
  0x20, 0x33, 0x35, 0x64, 0x65, 0x20, 0x38, 0x37, 0x30, 0x34, 0x20, 0x64, 0x34, 0x33, 0x31, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2a, 0x2a,
  0x2a, 0x20, 0x46, 0x69, 0x72, 0x6d, 0x77, 0x61, 0x72, 0x65, 0x20, 0x2a, 0x2a, 0x2a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2a, 0x2a, 0x2a, 0x20, 0x46,
  0x69, 0x72, 0x6d, 0x77, 0x61, 0x72, 0x65, 0x20, 0x2a, 0x2a, 0x2a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2a, 0x2a, 0x2a, 0x20, 0x46, 0x69, 0x72, 0x6d, 0x77, 0x61,
  0x72, 0x65, 0x20, 0x2a, 0x2a, 0x2a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2a, 0x2a, 0x2a, 0x20, 0x46, 0x69, 0x72, 0x6d, 0x77, 0x61, 0x72, 0x65, 0x20, 0x2a, 0x2a, 0x2a, 0x0a,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2a, 0x2a, 0x2a, 0x20, 0x46, 0x69, 0x72, 0x6d, 0x77, 0x61, 0x72, 0x65, 0x20, 0x2a, 0x2a, 0x2a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x2a, 0x2a, 0x2a, 0x20, 0x46,
  0x69, 0x72, 0x6d, 0x77, 0x61, 0x72, 0x65, 0x20, 0x2a, 0x2a, 0x2a, 0x0a, 0x20, 0x20, 0x2a, 0x2a, 0x2a, 0x20, 0x46, 0x69, 0x72, 0x6d, 0x77, 0x61, 0x72, 0x65, 0x20, 0x2a, 0x2a, 0x2a, 0x0a, 0x2a,
  0x2a, 0x2a, 0x20, 0x46, 0x69, 0x72, 0x6d, 0x77, 0x61, 0x72, 0x65, 0x20, 0x2a, 0x2a, 0x2a, 0x0a
};

/*********************************************************************
*
*       Static
*
**********************************************************************
*/
static int            _NumBytesDownload;
static U16            _BlockNo;
static I8             _DownloadEvent;

#if MAIN_INTERFACE == 0
static USB_HID_HANDLE _hInst;
static char           _ac[USB_HS_INT_MAX_PACKET_SIZE];
#endif
#if MAIN_INTERFACE == 1
static USB_CDC_HANDLE _hInst;
static char           _ac[USB_HS_BULK_MAX_PACKET_SIZE];
#endif

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

/*********************************************************************
*
*       _AddHID
*
*  Function description
*    Add HID class to USB stack
*/
#if MAIN_INTERFACE == 0
static USB_HID_HANDLE _AddHID(void) {
  static U8 _abOutBuffer[USB_HS_INT_MAX_PACKET_SIZE];

  USB_HID_INIT_DATA     InitData;
  USB_ADD_EP_INFO       EPIntIn;
  USB_ADD_EP_INFO       EPIntOut;
  USB_HID_HANDLE        hInst;

  memset(&InitData, 0, sizeof(InitData));
  EPIntIn.Flags           = 0;                             // Flags not used.
  EPIntIn.InDir           = USB_DIR_IN;                    // IN direction (Device to Host)
  EPIntIn.Interval        = 8;                             // Interval of 1 ms (125 us * 8)
  EPIntIn.MaxPacketSize   = USB_HS_INT_MAX_PACKET_SIZE;    // Maximum packet size (64 for Interrupt).
  EPIntIn.TransferType    = USB_TRANSFER_TYPE_INT;         // Endpoint type - Interrupt.
  InitData.EPIn = USBD_AddEPEx(&EPIntIn, NULL, 0);

  EPIntOut.Flags           = 0;                             // Flags not used.
  EPIntOut.InDir           = USB_DIR_OUT;                   // OUT direction (Host to Device)
  EPIntOut.Interval        = 8;                             // Interval of 1 ms (125 us * 8)
  EPIntOut.MaxPacketSize   = USB_HS_INT_MAX_PACKET_SIZE;    // Maximum packet size (64 for Interrupt).
  EPIntOut.TransferType    = USB_TRANSFER_TYPE_INT;         // Endpoint type - Interrupt.
  InitData.EPOut = USBD_AddEPEx(&EPIntOut, _abOutBuffer, sizeof(_abOutBuffer));

  InitData.pReport = _aHIDReport;
  InitData.NumBytesReport  = sizeof(_aHIDReport);
  hInst = USBD_HID_Add(&InitData);
  return hInst;
}
#endif

/*********************************************************************
*
*       _AddCDC
*
*  Function description
*    Add communication device class to USB stack
*/
#if MAIN_INTERFACE == 1
static USB_CDC_HANDLE _AddCDC(void) {
  static U8             _abOutBuffer[USB_HS_BULK_MAX_PACKET_SIZE];
  USB_CDC_INIT_DATA     InitData;
  USB_ADD_EP_INFO       EPBulkIn;
  USB_ADD_EP_INFO       EPBulkOut;
  USB_ADD_EP_INFO       EPIntIn;
  USB_CDC_HANDLE        hInst;

  memset(&InitData, 0, sizeof(InitData));
  EPBulkIn.Flags          = 0;                             // Flags not used.
  EPBulkIn.InDir          = USB_DIR_IN;                    // IN direction (Device to Host)
  EPBulkIn.Interval       = 0;                             // Interval not used for Bulk endpoints.
  EPBulkIn.MaxPacketSize  = USB_HS_BULK_MAX_PACKET_SIZE;   // Maximum packet size (512 for Bulk in high-speed).
  EPBulkIn.TransferType   = USB_TRANSFER_TYPE_BULK;        // Endpoint type - Bulk.
  InitData.EPIn  = USBD_AddEPEx(&EPBulkIn, NULL, 0);

  EPBulkOut.Flags         = 0;                             // Flags not used.
  EPBulkOut.InDir         = USB_DIR_OUT;                   // OUT direction (Host to Device)
  EPBulkOut.Interval      = 0;                             // Interval not used for Bulk endpoints.
  EPBulkOut.MaxPacketSize = USB_HS_BULK_MAX_PACKET_SIZE;   // Maximum packet size (512 for Bulk in high-speed).
  EPBulkOut.TransferType  = USB_TRANSFER_TYPE_BULK;        // Endpoint type - Bulk.
  InitData.EPOut = USBD_AddEPEx(&EPBulkOut, _abOutBuffer, sizeof(_abOutBuffer));

  EPIntIn.Flags           = 0;                             // Flags not used.
  EPIntIn.InDir           = USB_DIR_IN;                    // IN direction (Device to Host)
  EPIntIn.Interval        = 64;                            // Interval of 8 ms (64 * 125us)
  EPIntIn.MaxPacketSize   = USB_HS_INT_MAX_PACKET_SIZE;    // Maximum packet size (64 for Interrupt).
  EPIntIn.TransferType    = USB_TRANSFER_TYPE_INT;         // Endpoint type - Interrupt.
  InitData.EPInt = USBD_AddEPEx(&EPIntIn, NULL, 0);

  hInst = USBD_CDC_Add(&InitData);
  return hInst;
}
#endif

/*********************************************************************
*
*       _Download
*
*  Function description
*    Called, if the host has send a download packet.
*/
static void _Download(int NumBytes, U16 BlockNum) {
  _BlockNo          = BlockNum;
  _NumBytesDownload = NumBytes;
  _DownloadEvent    = 1;
}

/*********************************************************************
*
*       _Upload
*
*  Function description
*    Called, if the host has requested upload data.
*/
static int _Upload(int bStart, U16 BlockNum, U16 NumBytes, const U8 ** ppData) {
  static unsigned Addr = 0;

  if (bStart != 0) {
    Addr = 0;
  }
  if (NumBytes > sizeof(_FirmwareForUpload) - Addr) {
    NumBytes = sizeof(_FirmwareForUpload) - Addr;
  }
  *ppData = _FirmwareForUpload + Addr;
  Addr += NumBytes;
  USBD_Logf_Application("Upload %u bytes, block #%u", NumBytes, BlockNum);
  return (int)NumBytes;
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/

/*********************************************************************
*
*       USBD_DFU_MixedMode_Init
*
*  Function description
*    Add DFU function to USB stack
*/
void USBD_DFU_MixedMode_Init(void) {
  USBD_DFU_Add(&_DFUInfo);
  USBD_DFU_SetMSDescInfo();
}

/*********************************************************************
*
*       USBD_DFU_MixedMode_RunTask
*
* Function description
*   USB handling task.
*/
void USBD_DFU_MixedMode_RunTask(void *dummy) {
#if MAIN_INTERFACE == 1
  int NumBytesReceived;
#endif

  USB_USE_PARA(dummy);
  USBD_DFU_SetPollTimeout(10);
  for (;;) {
    //
    // Wait for configuration
    //
    while ((USBD_GetState() & (USB_STAT_CONFIGURED | USB_STAT_SUSPENDED)) != USB_STAT_CONFIGURED) {
      _DownloadEvent = 0;
      BSP_ToggleLED(0);
      USB_OS_Delay(50);
    }
    BSP_SetLED(0);
#if MAIN_INTERFACE == 0
    if (USBD_HID_Read(_hInst, &_ac[0], OUTPUT_REPORT_SIZE, 50) > 0) {
      _ac[0]++;
      USBD_HID_Write(_hInst, &_ac[0], INPUT_REPORT_SIZE, 500);
    }
#endif
#if MAIN_INTERFACE == 1
    NumBytesReceived = USBD_CDC_Receive(_hInst, &_ac[0], sizeof(_ac), 50);
    if (NumBytesReceived > 0) {
      USBD_CDC_Write(_hInst, &_ac[0], NumBytesReceived, 0);
    }
#endif
    if (_DownloadEvent != 0) {
      if (_NumBytesDownload < 0) {
        USBD_Logf_Application("Download aborted by host");
        _DownloadEvent = 0;
      }
      if (_NumBytesDownload > 0) {
        USBD_Logf_Application("Download received, block #%u:", _BlockNo);
        USBD_LogHexDump(USB_MTYPE_INFO, _NumBytesDownload, _Buff);
        USB_OS_Delay(300);
        _DownloadEvent = 0;
        USBD_DFU_Ack();
      }
      if (_NumBytesDownload == 0) {
        USBD_Logf_Application("Download finished, now manifestation");
        USBD_DFU_SetPollTimeout(500);
        _DownloadEvent = 0;
        USBD_DFU_Ack();
        USB_OS_Delay(2000);
        USBD_Logf_Application("Done.");
        USBD_DFU_ManifestComplt();
      }
    }
  }
}

/*********************************************************************
*
*       MainTask
*/
#if USBD_SAMPLE_NO_MAINTASK == 0
void MainTask(void) {
  USBD_Init();
  USBD_DFU_MixedMode_Init();
#if MAIN_INTERFACE == 0
  _hInst = _AddHID();
#endif
#if MAIN_INTERFACE == 1
  USBD_EnableIAD();
  _hInst = _AddCDC();
#endif
  USBD_SetDeviceInfo(&_DeviceInfo);
  USBD_Start();
  USBD_DFU_MixedMode_RunTask(NULL);
}
#endif

